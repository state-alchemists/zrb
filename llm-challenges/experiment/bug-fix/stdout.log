  [2mUser 0 checking stock...
[0m  [2mUser 1 checking stock...
[0m  [2mUser 2 checking stock...
[0m  [2mUser 3 checking stock...
[0m  [2mUser 4 checking stock...
[0m  [2mUser 0 purchased 3. Remaining: 7
[0m  [2mUser 1 purchased 3. Remaining: 4
[0m  [2mUser 2 purchased 3. Remaining: 1
[0m  [2mUser 3 purchased 3. Remaining: -2
[0m  [2mUser 4 purchased 3. Remaining: -5
[0m  [2mFinal Stock: -5
[0m  [2mUser 0 checking stock...
[0m  [2mUser 1 checking stock...
[0m  [2mUser 2 checking stock...
[0m  [2mUser 3 checking stock...
[0m  [2mUser 4 checking stock...
[0m  [2mUser 0 purchased 3. Remaining: 7
[0m  [2mUser 1 purchased 3. Remaining: 4
[0m  [2mUser 2 purchased 3. Remaining: 1
[0m  [2mUser 3 failed to purchase. Stock low.
[0m  [2mUser 4 failed to purchase. Stock low.
[0m  [2mFinal Stock: 1
[0m  [2m=== Testing Concurrent Purchases ===
[0m  [2mUser 0 checking stock...
[0m  [2mUser 1 checking stock...
[0m  [2mUser 2 checking stock...
[0m  [2mUser 3 checking stock...
[0m  [2mUser 4 checking stock...
[0m  [2mUser 5 checking stock...
[0m  [2mUser 6 checking stock...
[0m  [2mUser 7 checking stock...
[0m  [2mUser 0 purchased 2. Remaining: 8
[0m  [2mUser 1 purchased 2. Remaining: 6
[0m  [2mUser 2 purchased 2. Remaining: 4
[0m  [2mUser 3 purchased 2. Remaining: 2
[0m  [2mUser 4 purchased 2. Remaining: 0
[0m  [2mUser 5 failed to purchase. Stock low.
[0m  [2mUser 6 failed to purchase. Stock low.
[0m  [2mUser 7 failed to purchase. Stock low.
[0m  [2m
[0m  [2mSuccessful purchases: 5
[0m  [2mFinal Stock: 0
[0m  [2mâœ“ Concurrent purchases test passed!
[0m  [2m
[0m  [2m=== Testing Random Amounts ===
[0m  [2mUser 0 checking stock...
[0m  [2mUser 1 checking stock...
[0m  [2mUser 2 checking stock...
[0m  [2mUser 3 checking stock...
[0m  [2mUser 4 checking stock...
[0m  [2mUser 5 checking stock...
[0m  [2mUser 6 checking stock...
[0m  [2mUser 7 checking stock...
[0m  [2mUser 8 checking stock...
[0m  [2mUser 9 checking stock...
[0m  [2mUser 0 purchased 2. Remaining: 8
[0m  [2mUser 1 purchased 4. Remaining: 4
[0m  [2mUser 2 purchased 2. Remaining: 2
[0m  [2mUser 3 failed to purchase. Stock low.
[0m  [2mUser 4 failed to purchase. Stock low.
[0m  [2mUser 5 failed to purchase. Stock low.
[0m  [2mUser 6 failed to purchase. Stock low.
[0m  [2mUser 7 purchased 1. Remaining: 1
[0m  [2mUser 8 failed to purchase. Stock low.
[0m  [2mUser 9 failed to purchase. Stock low.
[0m  [2m
[0m  [2mRandom amounts test:
[0m  [2mFinal Stock: 1
[0m  [2mâœ“ Random amounts test passed!
[0m  [2m=== Run {1..3} ===
[0m  [2mUser 0 checking stock...
[0m  [2mUser 1 checking stock...
[0m  [2mUser 2 checking stock...
[0m  [2mUser 3 checking stock...
[0m  [2mUser 4 checking stock...
[0m  [2mUser 0 purchased 3. Remaining: 7
[0m  [2mUser 1 purchased 3. Remaining: 4
[0m  [2mUser 2 purchased 3. Remaining: 1
[0m  [2mUser 3 failed to purchase. Stock low.
[0m  [2mUser 4 failed to purchase. Stock low.
[0m  [2mFinal Stock: 1
[0m  [2m
[0m  [2mUser 0 checking stock...
[0m  [2mUser 1 checking stock...
[0m  [2mUser 2 checking stock...
[0m  [2mUser 3 checking stock...
[0m  [2mUser 4 checking stock...
[0m  [2mUser 0 purchased 3. Remaining: 7
[0m  [2mUser 1 purchased 3. Remaining: 4
[0m  [2mUser 2 purchased 3. Remaining: 1
[0m  [2mUser 3 failed to purchase. Stock low.
[0m  [2mUser 4 failed to purchase. Stock low.
[0m  [2mFinal Stock: 1
[0m  [2mUser 0 checking stock...
[0m  [2mUser 1 checking stock...
[0m  [2mUser 2 checking stock...
[0m  [2mUser 3 checking stock...
[0m  [2mUser 4 checking stock...
[0m  [2mUser 0 purchased 3. Remaining: 7
[0m  [2mUser 1 purchased 3. Remaining: 4
[0m  [2mUser 2 purchased 3. Remaining: 1
[0m  [2mUser 3 failed to purchase. Stock low.
[0m  [2mUser 4 failed to purchase. Stock low.
[0m  [2mFinal Stock: 1
[0m  [2mUser 0 checking stock...
[0m  [2mUser 1 checking stock...
[0m  [2mUser 2 checking stock...
[0m  [2mUser 3 checking stock...
[0m  [2mUser 4 checking stock...
[0m  [2mUser 0 purchased 3. Remaining: 7
[0m  [2mUser 1 purchased 3. Remaining: 4
[0m  [2mUser 2 purchased 3. Remaining: 1
[0m  [2mUser 3 failed to purchase. Stock low.
[0m  [2mUser 4 failed to purchase. Stock low.
[0m  [2mFinal Stock: 1
[0m  [2mUser 0 checking stock...
[0m  [2mUser 1 checking stock...
[0m  [2mUser 2 checking stock...
[0m  [2mUser 3 checking stock...
[0m  [2mUser 4 checking stock...
[0m  [2mUser 0 purchased 3. Remaining: 7
[0m  [2mUser 1 purchased 3. Remaining: 4
[0m  [2mUser 2 purchased 3. Remaining: 1
[0m  [2mUser 3 failed to purchase. Stock low.
[0m  [2mUser 4 failed to purchase. Stock low.
[0m  [2mFinal Stock: 1
[0m## Summary

I have successfully fixed the race condition in `inventory_system.py` by implementing an `asyncio.Lock` synchronization mechanism. Here's what was done:

### Problem
The original code had a race condition where:
1. Multiple users could simultaneously check the stock and see there was enough
2. After the simulated DB latency (`await asyncio.sleep(0.1)`), they would all decrement the stock
3. This caused the stock to go negative (down to -5 in the example)

### Solution
Added an `asyncio.Lock` to the `Inventory` class:
1. Created a lock instance in `__init__`: `self.lock = asyncio.Lock()`
2. Used `async with self.lock:` to ensure exclusive access to the critical section
3. The critical section includes both the stock check (`if self.stock >= amount:`) and the stock update (`self.stock -= amount`)

### Key Benefits
1. **Thread-safe**: Only one purchase operation can check and update the stock at a time
2. **Non-blocking for failed purchases**: Users who can't purchase due to insufficient stock don't block others unnecessarily
3. **Maintains async benefits**: While purchases are serialized at the stock update level, the system still benefits from async I/O for other operations
4. **Prevents negative stock**: The stock never goes below zero

### Verification
- Ran multiple tests showing consistent behavior
- Stock remains non-negative in all scenarios
- Only the maximum possible purchases succeed (3 users succeed, 2 fail in the original example)
- Final stock is correct (1 item remaining)

The fix is minimal, efficient, and correctly solves the race condition while maintaining the async nature of the application.
